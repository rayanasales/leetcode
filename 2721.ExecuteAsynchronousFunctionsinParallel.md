# 2721. Execute Asynchronous Functions in Parallel

**_ğŸª´ Difficulty: `Medium`_**

**_â¤ï¸ Leetcode Problem Description: [Execute Asynchronous Functions in Parallel - Problem - Description](https://leetcode.com/problems/execute-asynchronous-functions-in-parallel/description/)_**

**_â¤ï¸ Leetcode Solution by Rayana Sales: [Execute Asynchronous Functions in Parallel - Solution - Rayana Sales](https://leetcode.com/problems/execute-asynchronous-functions-in-parallel/solutions/5614491/simple-beginner-friendly-9-lines-solution-several-promises-in-parallel/)_**

**_ğŸ’ğŸ»â€â™€ï¸ All my solved LeetCode problems on GitHub: [rayanasales/leetcode](https://github.com/rayanasales/leetcode)_**

**_â¤ï¸â€ğŸ”¥â¤ï¸â€ğŸ”¥â¤ï¸â€ğŸ”¥ If it's help, please up ğŸ” vote! â¤ï¸â€ğŸ”¥â¤ï¸â€ğŸ”¥â¤ï¸â€ğŸ”¥_**

---

## Solution in javascript

```jsx
var promiseAll = function (functions) {
  return new Promise((resolve, reject) => {
    const results = []; // Array to store results in the original order
    let completedPromises = 0; // Counter to track how many promises have been resolved

    functions.forEach((fn, i) => {
      fn()
        .then((result) => {
          results[i] = result; // Store result at the correct index
          completedPromises++; // Increment counter for each resolved promise
          if (completedPromises === functions.length) resolve(results); // If all promises are done, resolve with the results array
        })
        .catch(reject); // If any promise fails, reject immediately
    });
  });
};
```

# Explanation

### **What Are Promises?**

- **Promises**Â in JavaScript are a way to handle asynchronous operations, which are operations that take some time to complete, such as fetching data from a server or waiting for a timer.
- A promise can be in one of three states:
  - **Pending:**Â The operation is still ongoing.
  - **Resolved (Fulfilled):**Â The operation completed successfully, and the promise now has a result.
  - **Rejected:**Â The operation failed, and the promise has an error or reason for the failure.
- Promises allow us to write code that can react to these different outcomes, usingÂ `.then()`Â for successful resolutions andÂ `.catch()`Â for errors.

### **Strategy Used in the Code:**

1. **Creating a New Promise:**
   - The code starts by creating a new promise. This is the promise that will eventually hold the results of all the asynchronous operations in theÂ `functions`Â array. This promise will either resolve (success) when all the individual promises have finished successfully or reject (failure) if any one of them fails.
2. **Tracking Results:**
   - We need to keep track of the results of each asynchronous operation. To do this, we create an emptyÂ `results`Â array. This array will store the results in the same order as the originalÂ `functions`Â array, ensuring that the final output respects the original order.
3. **Counting Completed Promises:**
   - We also set up a counter calledÂ `completedPromises`Â to track how many of the promises have finished. This counter helps us know when all the promises have completed successfully so that we can resolve our main promise with the results.
4. **Handling Each Function:**
   - We loop over theÂ `functions`Â array usingÂ `forEach`. For each function, we:
     - Call the function to start the asynchronous operation. The function returns a promise.
     - UseÂ `.then()`Â to handle the case where the promise resolves successfully. When a promise resolves, we store its result in theÂ `results`Â array at the correct position (using the indexÂ `i`Â from the loop).
     - Increment theÂ `completedPromises`Â counter to keep track of how many promises have successfully completed. If this counter equals the total number of functions, it means all promises are done, and we resolve the main promise with theÂ `results`Â array.
     - UseÂ `.catch()`Â to handle the case where any promise fails. If any promise rejects, we immediately reject the main promise with the error, meaning the whole operation fails.
5. **Final Output:**
   - If all promises resolve successfully, the final output is an array of results, ordered according to the original order of the functions. If any promise fails, the operation stops immediately, and the error is propagated.

---

# **_HOPE YOU ENJOYED MY EXPLANATION. UPVOTE if this was helpful ğŸ”ğŸ”ğŸ”â¤ï¸â¤ï¸â¤ï¸_**

## **_Check out all my solved LeetCode problems on GitHub: [rayanasales/leetcode](https://github.com/rayanasales/leetcode) ğŸ¤™ğŸ˜šğŸ¤˜_**
