# 257. Binary Tree Paths

**_ğŸŒ± Difficulty: `Easy`_**

**_â¤ï¸ Leetcode Problem Description:_** [Binary Tree Paths - Problem - Description](https://leetcode.com/problems/binary-tree-paths/description/)

**_â¤ï¸ Leetcode Solution by Rayana Sales:_ [Binary Tree Paths _- Solution - Rayana Sales_](https://leetcode.com/problems/binary-tree-paths/solutions/5696042/runtime-52ms-beats-83-48-simple-to-understand-javascript-solution/)**

**_ğŸ’ğŸ»â€â™€ï¸ All my solved LeetCode problems on GitHub: [rayanasales/leetcode](https://github.com/rayanasales/leetcode)_**

**_â¤ï¸â€ğŸ”¥â¤ï¸â€ğŸ”¥â¤ï¸â€ğŸ”¥ If it's help, please up ğŸ” vote! â¤ï¸â€ğŸ”¥â¤ï¸â€ğŸ”¥â¤ï¸â€ğŸ”¥_**

---

## Background: what you need to know

1. **Recursive Depth-First Search (DFS)**:
   - The most natural way to explore all paths from the root to the leaves in a binary tree is by using DFS. This approach will traverse the tree, visiting each node and building the path as it goes.
   - Whenever a leaf node (a node with no children) is reached, the current path is added to the result.
2. **Path Construction**:
   - As we traverse the tree, we accumulate the path in a string. If the current node has children, we continue appending to the path string. When we reach a leaf node, we add the full path string to the result array.
3. **Edge Cases**:
   - If the tree is empty (i.e., `root` is null), the result should be an empty array.
   - If the tree has only one node, the result should contain just one path, which is the value of that single node.

## Javascript Solution

```jsx
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */

/**
 * @param {TreeNode} root
 * @return {string[]}
 */
var binaryTreePaths = function (root) {
  // Initialize an array to store all root-to-leaf paths.
  const result = [];

  // Helper function to perform DFS on the tree.
  function dfs(node, path) {
    if (node) {
      // If the current node is not null
      // Append the current node's value to the path.
      path += node.val;

      // If the current node is a leaf (no left and right children), add the path to the result.
      if (!node.left && !node.right) {
        result.push(path);
      } else {
        // If the current node is not a leaf, continue the DFS on both children.
        // Add '->' to the path before going deeper.
        path += "->";
        dfs(node.left, path);
        dfs(node.right, path);
      }
    }
  }

  // Start DFS with the root node and an empty path string.
  dfs(root, "");

  // Return the array of all root-to-leaf paths.
  return result;
};
```

## Explanation of the Code

1. **Initialization**:
   - `result`: This array will store all the paths from the root to each leaf node.
2. **DFS Helper Function**:
   - The `dfs` function is a recursive function that takes the current `node` and the `path` string accumulated so far as its parameters.
   - For each node, we append its value to the `path` string.
   - If the node is a leaf (both `left` and `right` are null), we push the `path` string to the `result` array.
   - If the node is not a leaf, we append `"->"` to the `path` and recursively call `dfs` on the left and right children.
3. **Edge Handling**:
   - If the input `root` is null, the DFS is never initiated, and the `result` array remains empty.
4. **Efficiency**:
   - The time complexity of this approach is O(N), where N is the number of nodes in the tree. This is because we visit each node exactly once.
   - The space complexity is O(H), where H is the height of the tree, which corresponds to the depth of the recursion stack.

---

# **_HOPE YOU ENJOYED MY EXPLANATION. UPVOTE if this was helpful ğŸ”ğŸ”ğŸ”â¤ï¸â¤ï¸â¤ï¸_**

## **_Check out all my solved LeetCode problems on GitHub: [rayanasales/leetcode](https://github.com/rayanasales/leetcode) ğŸ¤™ğŸ˜šğŸ¤˜_**
