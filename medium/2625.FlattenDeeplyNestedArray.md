# 2625. Flatten Deeply Nested Array

[Flatten Deeply Nested Array - LeetCode](https://leetcode.com/problems/flatten-deeply-nested-array/description/)

‚è∞ Solved in 34:21 mins

</br>

# Solution

```jsx
var flat = function (arr, n) {
  if (n === 0) return arr;

  let output = [];

  function dig(array, depth) {
    array.forEach((current) => {
      if (!Array.isArray(current)) {
        output.push(current);
      } else {
        if (depth < n) {
          // Continue flattening
          dig(current, depth + 1); // ++dept or depth++ does not work, because this will change the original depth, and we need to keep the original value for each depht
        } else {
          // Do not flatten beyond depth
          output.push(current);
        }
      }
    });
  }

  dig(arr, 0); // Start with depth 0

  return output;
};
```

# Explanation

### Diferen√ßa entre `depth++`, `++depth` e `depth + 1`

1. **`depth++`**:
   - Este √© o operador de p√≥s-incremento. Ele retorna o valor atual de `depth` e, em seguida, incrementa `depth`.
   - Se `depth` for 0, `depth++` retornar√° 0 e depois `depth` ser√° incrementado para 1.
2. **`++depth`**:
   - Este √© o operador de pr√©-incremento. Ele incrementa `depth` e, em seguida, retorna o valor incrementado.
   - Se `depth` for 0, `++depth` incrementar√° `depth` para 1 e depois retornar√° 1.
3. **`depth + 1`**:
   - Esta express√£o simplesmente calcula o valor de `depth` mais 1, mas n√£o altera `depth`.
   - Se `depth` for 0, `depth + 1` resultar√° em 1, mas `depth` ainda ser√° 0.

### Por que `depth++` ou `++depth` n√£o funcionam no seu caso

No seu c√≥digo original, voc√™ quer passar a profundidade incrementada para a pr√≥xima chamada recursiva sem alterar a profundidade no n√≠vel atual. Isso √© importante para manter o controle correto da profundidade em cada n√≠vel da recurs√£o.

Quando voc√™ usa `depth + 1`, voc√™ est√° calculando a profundidade incrementada e passando esse valor para a fun√ß√£o recursiva, mas `depth` em si n√£o √© modificado fora dessa chamada.

Se voc√™ usar `depth++` ou `++depth`, voc√™ est√° tentando modificar `depth` diretamente, o que afeta a profundidade em chamadas subsequentes da fun√ß√£o recursiva de forma incorreta. Aqui est√° um exemplo do que acontece:

```jsx
// depth++ (p√≥s-incremento)
let depth = 0;
console.log(depth++); // Output: 0 (usa o valor atual, depois incrementa)
console.log(depth); // Output: 1 (agora depth √© incrementado)

// ++depth (pr√©-incremento)
depth = 0;
console.log(++depth); // Output: 1 (incrementa primeiro, depois usa o valor)
console.log(depth); // Output: 1 (depth √© incrementado)

// depth + 1 (n√£o modifica depth)
depth = 0;
console.log(depth + 1); // Output: 1 (calcula o valor, n√£o modifica depth)
console.log(depth); // Output: 0 (depth ainda √© o mesmo)
```

### No contexto do seu c√≥digo

No seu caso, voc√™ quer passar `depth + 1` para a chamada recursiva sem modificar `depth`:

```jsx
function dig(array, depth) {
  array.forEach((current) => {
    if (!Array.isArray(current)) {
      output.push(current);
    } else {
      if (depth < n) {
        // Continue flattening
        dig(current, depth + 1);
      } else {
        // Do not flatten beyond depth
        output.push(current);
      }
    }
  });
}
```

Aqui, `depth + 1` passa a profundidade incrementada para a chamada recursiva, mas `depth` permanece inalterado para o loop atual. Isso garante que a profundidade seja corretamente incrementada apenas para a pr√≥xima chamada recursiva.

Espero que isso esclare√ßa a diferen√ßa e o motivo pelo qual `depth + 1` √© a abordagem correta no seu caso! Se tiver mais d√∫vidas, estou aqui para ajudar.

## Complete explanation of the algorithm

### Explanation:

1. **Check for Base Case**:

   ```jsx
   if (n === 0) return arr;
   ```

   - If the given depth `n` is 0, we return the original array because no flattening should occur.

2. **Initialize Output Array**:

   ```jsx
   let output = [];
   ```

   - We create an empty array `output` to store the flattened elements.

3. **Define the Recursive Function**:

   ```jsx
   function dig(array, depth) {

   ```

   - We define a helper function `dig` that will process the array recursively.

4. **Iterate Over Elements**:

   ```jsx
   array.forEach((current) => {

   ```

   - We use `forEach` to loop through each element in the array.

5. **Check if Element is an Array**:

   ```jsx
   if (!Array.isArray(current)) {
       output.push(current);

   ```

   - If the current element is not an array, we add it directly to the `output`.

6. **Handle Nested Arrays**:

   ```jsx
   } else {
       if (depth < n) {
           dig(current, depth + 1);
       } else {
           output.push(current);
       }
   }

   ```

   - If the current element is an array:
     - We check if the current depth is less than `n`.
     - If it is, we call the `dig` function recursively, increasing the depth by 1 (`depth + 1`).
     - If the current depth is not less than `n`, we add the entire sub-array to the `output` without flattening it further.

7. **Start Recursive Flattening**:

   ```jsx
   dig(arr, 0);
   ```

   - We initiate the recursive flattening process by calling `dig` with the original array and starting depth of 0.

8. **Return the Flattened Array**:

   ```jsx
   return output;
   ```

   - Finally, we return the `output` array, which contains the flattened elements up to the specified depth.

This code ensures that the array is flattened correctly according to the given depth `n` without using the built-in `Array.flat` method.

# Leetcode post

[ü§ôüòöü§ò Flatten Deeply Nested Array ‚úÖ simple, beginner friendly](https://leetcode.com/problems/flatten-deeply-nested-array/)
