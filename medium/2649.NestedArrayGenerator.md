# 2649. Nested Array Generator

[Nested Array Generator - LeetCode](https://leetcode.com/problems/nested-array-generator/description/)

⏰ Solved in 14:21

# Solution

```jsx
var inorderTraversal = function* (arr) {
  for (const element of arr) {
    if (Array.isArray(element)) {
      yield* inorderTraversal(element); // Recursively yield values from nested arrays
    } else {
      yield element; // Yield the integer
    }
  }
};

/**
 * const gen = inorderTraversal([1, [2, 3]]);
 * gen.next().value; // 1
 * gen.next().value; // 2
 * gen.next().value; // 3
 */
```

# Leetcode post

[Nested Array Generator - LeetCode](https://leetcode.com/problems/nested-array-generator/)

# Explanation

To solve this problem, we need to create a generator function that performs an inorder traversal on a multi-dimensional array. The goal is to yield each integer in the array in the correct order without creating a flattened version of the array beforehand.

Here’s a super short and efficient implementation:

```jsx
var inorderTraversal = function* (arr) {
  for (const element of arr) {
    if (Array.isArray(element)) {
      yield* inorderTraversal(element); // Recursively yield values from nested arrays
    } else {
      yield element; // Yield the integer
    }
  }
};

/**
 * Example Usage:
 * const gen = inorderTraversal([1, [2, [3, 4], 5], 6]);
 * console.log(gen.next().value); // 1
 * console.log(gen.next().value); // 2
 * console.log(gen.next().value); // 3
 * console.log(gen.next().value); // 4
 * console.log(gen.next().value); // 5
 * console.log(gen.next().value); // 6
 */
```

### **Detailed Explanation:**

1. **Generator Function:**
   - `inorderTraversal` is a generator function, denoted by the `function*` syntax. A generator function can yield multiple values over time, one at a time, and can be paused and resumed.
2. **Iterating Through the Array:**
   - We use a `for...of` loop to iterate over each `element` in the array `arr`.
   - The `for...of` loop works well with generator functions because it allows us to traverse each element sequentially.
3. **Checking If the Element Is an Array:**
   - For each `element`, we check if it is an array using `Array.isArray(element)`.
   - If `element` is an array, we recursively call `inorderTraversal(element)` to perform an inorder traversal on this sub-array.
4. **Yielding Values Recursively:**
   - If the `element` is an array, we use `yield* inorderTraversal(element);` to delegate the yield operation to the recursive generator function call. This effectively flattens the array structure in an inorder manner, one element at a time.
   - If the `element` is not an array, we simply `yield` the `element` (which is an integer) directly.
5. **Yielding All Values:**
   - The generator will yield all integers in the array in the correct inorder sequence. If the array contains nested arrays, it will explore them recursively.

### **Why This Approach?**

- **No Flattening Needed:** The solution doesn't require creating a new flattened array, thus saving memory and adhering to the problem constraints.
- **Recursive Traversal:** It uses recursion to handle the nested structure, making the code concise and efficient.
- **Yielding on Demand:** The generator function allows us to yield values on demand, which is useful for large datasets where you don't want to load everything into memory at once.
