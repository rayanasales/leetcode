# 342. Power of Four

**_ğŸŒ± Difficulty: `Easy`_**

**_â¤ï¸ Leetcode Problem Description:_** [Power of Four - Problem - Description](https://leetcode.com/problems/power-of-four/description/)

**_â¤ï¸ Leetcode Solution by Rayana Sales:_** [Power of Four - Solution - Rayana Sales](https://leetcode.com/problems/power-of-four/solutions/5716246/runtime-0ms-beats-100-simple-to-understand-java-javascript-solution)

**_ğŸ’ğŸ»â€â™€ï¸ All my solved LeetCode problems on GitHub: [rayanasales/leetcode](https://github.com/rayanasales/leetcode)_**

**_â¤ï¸â€ğŸ”¥â¤ï¸â€ğŸ”¥â¤ï¸â€ğŸ”¥ If it's help, please up ğŸ” vote! â¤ï¸â€ğŸ”¥â¤ï¸â€ğŸ”¥â¤ï¸â€ğŸ”¥_**

---

### **JavaScript Explanation and Solution**

In JavaScript, one of the most efficient ways to check if a number is a power of four without using loops or recursion is by leveraging bitwise operations. A power of four has the following properties:

1. It is a positive number.
2. It has only one bit set in its binary representation (i.e., itâ€™s a power of two).
3. The only set bit must be in an odd position (since the positions are 0-indexed).

**Bitwise Logic**:

- The bitwiseÂ `AND`Â operation betweenÂ `n`Â andÂ `n-1`Â should beÂ `0`Â to ensure it's a power of two.
- We check if the only set bit is in an odd position by using a maskÂ `0x55555555`. This hexadecimal number isÂ `01010101010101010101010101010101`Â in binary, which covers all odd positions.

Here's the JavaScript implementation:

```js
function isPowerOfFour(n) {
  // Check if n is positive, a power of two, and the only set bit is in an odd position.
  return n > 0 && (n & (n - 1)) === 0 && (n & 0x55555555) !== 0;
}
```

### **Java Explanation and Solution**

In Java, the logic is identical, but we need to be careful with data types because Java strictly checks types.

Here's the Java implementation:

```java
public class Solution {
    public boolean isPowerOfFour(int n) {
        // Check if n is positive, a power of two, and the only set bit is in an odd position.
        return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;
    }
}
```

### **Explanation:**

- **`n > 0`**: Ensures thatÂ `n`Â is positive.
- **`(n & (n - 1)) === 0`**: This check ensures thatÂ `n`Â is a power of two. Any number that is a power of two has only one bit set in its binary form. When you subtract 1 from such a number, all bits before the set bit become 1, and the set bit becomes 0. TheÂ `AND`Â operation betweenÂ `n`Â andÂ `n-1`Â will then beÂ `0`.
- **`(n & 0x55555555) !== 0`**: This ensures that the single set bit is in an odd position, which is necessary for the number to be a power of four.

### **Performance**

This approach runs in constant time, O(1), and has a runtime of 0ms on Leetcode. It minimizes potential overhead by using direct bitwise operations, which are highly efficient.

---

# **_HOPE YOU ENJOYED MY EXPLANATION. UPVOTE if this was helpful ğŸ”ğŸ”ğŸ”â¤ï¸â¤ï¸â¤ï¸_**

## **_Check out all my solved LeetCode problems on GitHub:Â [rayanasales/leetcode](https://github.com/rayanasales/leetcode)Â ğŸ¤™ğŸ˜šğŸ¤˜_**
