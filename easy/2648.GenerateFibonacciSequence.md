# 2648. Generate Fibonacci Sequence

[üçÑ 2648. Generate Fibonacci Sequence](https://leetcode.com/problems/generate-fibonacci-sequence/description/)

<aside>
‚è∞ Solved in 15:00
</aside>
</br>

# Solution

```js
/**
 * @return {Generator<number>}
 */
var fibGenerator = function* () {
  let current = 0; // Primeiro n√∫mero da sequ√™ncia Fibonacci
  let next = 1; // Segundo n√∫mero da sequ√™ncia Fibonacci

  while (true) {
    // Loop infinito para gerar a sequ√™ncia continuamente
    yield current; // Retorna o n√∫mero atual da sequ√™ncia
    [current, next] = [next, current + next]; // Atualiza `current` e `next` para os pr√≥ximos dois n√∫meros na sequ√™ncia
  }
};

// Exemplo de uso:
const gen = fibGenerator();
console.log(gen.next().value); // 0
console.log(gen.next().value); // 1
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
```

# Explanation

### 1. Como o `yield` funciona:

O `yield` √© uma funcionalidade usada em fun√ß√µes geradoras em JavaScript, que s√£o um tipo especial de fun√ß√£o que pode pausar sua execu√ß√£o e depois continuar de onde parou. Fun√ß√µes geradoras s√£o definidas com a sintaxe `function*()` ao inv√©s de apenas `function()`.

Quando a palavra-chave `yield` √© usada dentro de uma fun√ß√£o geradora, ela faz duas coisas principais:

1. **Retorna o valor especificado**: `yield` retorna o valor para o chamador da fun√ß√£o, similar ao `return` em fun√ß√µes normais.
2. **Pausa a execu√ß√£o da fun√ß√£o**: Diferente de `return`, que termina a fun√ß√£o, `yield` pausa a fun√ß√£o, mantendo seu estado interno (incluindo vari√°veis locais e posi√ß√£o no c√≥digo). Quando a fun√ß√£o √© chamada novamente, ela continua de onde parou.

No contexto do seu c√≥digo, `yield current` retorna o valor atual de `current` cada vez que a fun√ß√£o √© chamada e depois pausa, esperando a pr√≥xima chamada para continuar.

### 2. Desestrutura√ß√£o de Arrays:

A linha `[current, next] = [next, current + next];` √© um exemplo de desestrutura√ß√£o de arrays em JavaScript, que √© uma maneira sint√°tica de extrair m√∫ltiplos valores de um array e atribu√≠-los a vari√°veis em uma √∫nica opera√ß√£o.

- **Antes**: `current` cont√©m o n√∫mero atual da sequ√™ncia de Fibonacci, e `next` cont√©m o pr√≥ximo n√∫mero.
- **Depois**: Queremos atualizar `current` para ser o pr√≥ximo n√∫mero da sequ√™ncia, que √© o valor atual de `next`. Tamb√©m queremos que `next` seja atualizado para ser a soma de `current` (o n√∫mero atual) e `next` (o pr√≥ximo n√∫mero).

A desestrutura√ß√£o faz isso de forma compacta e clara:

- `[next, current + next]` cria temporariamente um array com os novos valores.
- `[current, next] =` atribui esses valores √†s vari√°veis `current` e `next` respectivamente.

### 3. Fun√ß√£o `next()` e iteradores:

Quando voc√™ cria uma fun√ß√£o geradora e a chama, ela retorna um objeto chamado **iterador**. Este objeto possui um m√©todo chamado `next()`, que √© usado para continuar a execu√ß√£o da fun√ß√£o geradora do ponto onde ela foi pausada pela √∫ltima vez.

- **`gen.next().value`**:
  - `gen` √© o iterador retornado pela fun√ß√£o geradora `fibGenerator`.
  - `next()` √© um m√©todo desse iterador que, quando chamado, continua a execu√ß√£o da fun√ß√£o geradora at√© encontrar o pr√≥ximo `yield`.
  - `value` √© uma propriedade do objeto retornado por `next()`, que cont√©m o valor fornecido pelo `yield`.

Al√©m de `next()`, os iteradores podem ter outros m√©todos como `return()` e `throw()`, que tamb√©m s√£o usados para controlar a execu√ß√£o da fun√ß√£o geradora:

- `return()` termina a fun√ß√£o geradora e retorna um valor dado.
- `throw()` √© usado para passar um erro para a fun√ß√£o geradora.

A t√©cnica de usar fun√ß√µes geradoras e iteradores √© uma parte importante do JavaScript, especialmente para opera√ß√µes que requerem pausa e continua√ß√£o, como processamento ass√≠ncrono ou manipula√ß√£o de grandes conjuntos de dados de forma eficiente.

Espero que isso esclare√ßa suas d√∫vidas! Se houver mais perguntas ou se precisar de mais explica√ß√µes, sinta-se √† vontade para perguntar.
