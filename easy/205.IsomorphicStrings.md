# 205. Isomorphic Strings

## Found at

[leetcode.com/problemset/all-code-essentials](https://leetcode.com/problemset/all-code-essentials/?sorting=W3sic29ydE9yZGVyIjoiREVTQ0VORElORyIsIm9yZGVyQnkiOiJESUZGSUNVTFRZIn1d&difficulty=EASY&page=1&topicSlugs=string)

## Leetcode link

[Isomorphic Strings - LeetCode](https://leetcode.com/problems/isomorphic-strings/description/)

## Solution

```jsx
var isIsomorphic = function (s, t) {
  // Edge case: If lengths of s and t are different, they can't be isomorphic
  if (s.length !== t.length) return false;

  // Create two arrays to store the mapping of characters (ASCII size is 256)
  let mapS = new Array(256).fill(-1); // Mapping from s to t
  let mapT = new Array(256).fill(-1); // Mapping from t to s

  // Iterate through the characters of the strings
  for (let i = 0; i < s.length; i++) {
    let charS = s.charCodeAt(i); // Get ASCII code for character in s
    let charT = t.charCodeAt(i); // Get ASCII code for character in t

    // Check if there's a mapping for charS in mapS
    if (mapS[charS] === -1 && mapT[charT] === -1) {
      // If both characters have not been mapped yet, create a new mapping
      mapS[charS] = charT;
      mapT[charT] = charS;
    } else {
      // If there's an existing mapping, check if it's consistent
      if (mapS[charS] !== charT || mapT[charT] !== charS) {
        return false;
      }
    }
  }

  // If we finish the loop without inconsistencies, the strings are isomorphic
  return true;
};
```

## Explanation

### **What Are Isomorphic Strings?**

Two strings,Â `s`Â andÂ `t`, are consideredÂ **isomorphic**Â if the characters inÂ `s`Â can be replaced to formÂ `t`Â while maintaining the order of characters. This means that there is a one-to-one mapping between characters inÂ `s`Â and characters inÂ `t`.

Key points to remember:

- **Consistent Mapping:**Â Each character inÂ `s`Â must map to exactly one character inÂ `t`.
- **No Overlapping Mappings:**Â No two characters inÂ `s`Â can map to the same character inÂ `t`.
- **Self-Mapping:**Â A character can map to itself, but it cannot map to multiple different characters.

**Examples:**

- **Example 1:**Â `s = "egg"`,Â `t = "add"`: The strings are isomorphic becauseÂ `e`Â maps toÂ `a`Â andÂ `g`Â maps toÂ `d`. The mapping is consistent and unique.
- **Example 2:**Â `s = "foo"`,Â `t = "bar"`: The strings are not isomorphic because the secondÂ `o`Â would need to map to bothÂ `a`Â andÂ `r`, which is not allowed.
- **Example 3:**Â `s = "paper"`,Â `t = "title"`: The strings are isomorphic becauseÂ `p`Â maps toÂ `t`,Â `a`Â maps toÂ `i`,Â `p`Â (again) maps toÂ `t`,Â `e`Â maps toÂ `l`, andÂ `r`Â maps toÂ `e`.

### **Solution Strategy**

To solve the problem efficiently, I used an array-based approach to map characters from one string to another. Here's the thought process behind the solution:

1. **Fixed Array Mapping:**Â Since the problem constraints guarantee that the strings consist of ASCII characters, I used two fixed-size arrays (`mapS`Â andÂ `mapT`) of size 256 (covering all possible ASCII characters). This allows for O(1) time complexity for both mapping and lookup operations.
2. **Iterate Through Strings:**Â I iterate through the characters of both strings simultaneously. For each pair of characters, I check:
   - If there is no existing mapping, I create a new one.
   - If there is an existing mapping, I ensure it is consistent with previous mappings. If it isnâ€™t, the strings are not isomorphic, and I returnÂ `false`.
3. **Efficiency:**Â By using arrays and direct indexing based on ASCII values, the solution is both time-efficient and space-efficient, making it optimal for large input sizes.

# Leetcode post

**Runtime 48ms Beats 98.03% ðŸŽ¯ðŸ’¯â¤ï¸â€ðŸ”¥ðŸ†ðŸ¥‡ Javascript solution & explanation ðŸ’¸ðŸ¤‘ðŸ’°ðŸ’²ðŸ¾ðŸ•¶ðŸ¤**

[Isomorphic Strings - LeetCode](https://leetcode.com/problems/isomorphic-strings/solutions/5681990/runtime-48ms-beats-98-03-javascript-solution-explanation/)
