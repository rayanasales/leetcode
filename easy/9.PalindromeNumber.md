# 9. Palindrome Number

## Found at

[Problems - LeetCode](https://leetcode.com/problemset/all-code-essentials/?sorting=W3sic29ydE9yZGVyIjoiREVTQ0VORElORyIsIm9yZGVyQnkiOiJESUZGSUNVTFRZIn1d&difficulty=EASY&page=1)

## Leetcode link

[Palindrome Number - LeetCode](https://leetcode.com/problems/palindrome-number/description/)

## Solution

```jsx
function isPalindrome(x) {
  // Early return for negative numbers and numbers ending in 0 (except 0 itself)
  if (x < 0 || (x % 10 === 0 && x !== 0)) {
    return false;
  }

  let reversedHalf = 0;

  // Reverse the second half of the number
  while (x > reversedHalf) {
    reversedHalf = reversedHalf * 10 + (x % 10);
    x = Math.floor(x / 10);
  }

  // Directly compare the two halves
  return x === reversedHalf || x === Math.floor(reversedHalf / 10);
}
```

## Explanation

1. **VerificaÃ§Ã£o Inicial:**

   ```jsx
   if (x < 0 || (x % 10 === 0 && x !== 0)) {
     return false;
   }
   ```

   - **Verificando nÃºmeros negativos**: Qualquer nÃºmero negativo nÃ£o pode ser um palÃ­ndromo porque o sinal negativo `-`nÃ£o existe no final do nÃºmero quando ele Ã© lido de trÃ¡s para frente. Por exemplo, `-121` seria lido como `121-`, que claramente nÃ£o Ã© um palÃ­ndromo.
   - **Verificando nÃºmeros que terminam em 0**: Qualquer nÃºmero que termina em `0` (exceto o prÃ³prio `0`) nÃ£o pode ser um palÃ­ndromo, pois o nÃºmero comeÃ§aria com `0` se lido ao contrÃ¡rio, o que nÃ£o Ã© possÃ­vel para nÃºmeros inteiros.

2. **Inicializando a variÃ¡vel `reversedHalf`:**

   ```jsx
   let reversedHalf = 0;
   ```

   - Essa variÃ¡vel serÃ¡ usada para construir a metade reversa do nÃºmero original. Por exemplo, se o nÃºmero original for `1221`, `reversedHalf` se tornarÃ¡ `12` quando o loop terminar.

3. **Loop para reverter metade do nÃºmero:**

   ```jsx
   while (x > reversedHalf) {
     reversedHalf = reversedHalf * 10 + (x % 10);
     x = Math.floor(x / 10);
   }
   ```

   - **CondiÃ§Ã£o do loop `while (x > reversedHalf)`**: O loop continua atÃ© que `x` seja menor ou igual a `reversedHalf`. Isso garante que estamos processando metade do nÃºmero.
   - **Revertendo a metade do nÃºmero**:
     - `(x % 10)` obtÃ©m o Ãºltimo dÃ­gito de `x`.
     - `reversedHalf = (reversedHalf * 10) + (x % 10)` adiciona esse Ãºltimo dÃ­gito Ã  `reversedHalf`, efetivamente construindo a versÃ£o reversa da metade do nÃºmero.
     - `x = Math.floor(x / 10)` remove o Ãºltimo dÃ­gito de `x` (ou seja, divide `x` por 10 e descarta o resto).
   - **Exemplo PrÃ¡tico**:
     - Se `x = 1221`, no primeiro ciclo:
       - `reversedHalf = 0 * 10 + 1 = 1`
       - `x = 1221 // 10 = 122`
     - No segundo ciclo:
       - `reversedHalf = 1 * 10 + 2 = 12`
       - `x = 122 // 10 = 12`
     - Agora, `x` Ã© igual a `reversedHalf`, entÃ£o o loop para.

4. **ComparaÃ§Ã£o Final:**

   ```jsx
   return x === reversedHalf || x === Math.floor(reversedHalf / 10);
   ```

   - **x === reversedHalf**: Para nÃºmeros com um nÃºmero par de dÃ­gitos, essa condiÃ§Ã£o verifica se a primeira metade do nÃºmero Ã© igual Ã  metade reversa.
     - Exemplo: `1221` -> ApÃ³s o loop, `x = 12` e `reversedHalf = 12`, entÃ£o `x === reversedHalf` Ã© `true`.
   - **x === Math.floor(reversedHalf / 10)**: Para nÃºmeros com um nÃºmero Ã­mpar de dÃ­gitos, essa condiÃ§Ã£o ignora o dÃ­gito do meio.
     - Exemplo: `12321` -> ApÃ³s o loop, `x = 12` e `reversedHalf = 123`. Dividindo `reversedHalf` por 10, obtemos `12`, entÃ£o `x === Math.floor(reversedHalf / 10)` Ã© `true`.

### Resumo do Funcionamento:

- O cÃ³digo divide o nÃºmero em duas metades: a primeira metade Ã© comparada diretamente com a versÃ£o reversa da segunda metade.
- Essa abordagem evita converter o nÃºmero em uma string, o que economiza memÃ³ria e operaÃ§Ãµes desnecessÃ¡rias, tornando o cÃ³digo mais eficiente.

## Leetcode post

**Simple, beginner friendly ğŸ¯ğŸ’¯â¤ï¸â€ğŸ”¥ğŸ†ğŸ¥‡ Javascript solution & explanation âœ…ğŸ•¶ğŸ¤ğŸ¤™ğŸ˜šğŸ¤˜**

[Palindrome Number - LeetCode](https://leetcode.com/problems/palindrome-number/solutions/5652719/simple-beginner-friendly-javascript-solution-explanation/)
